import { CONFIG } from '../config/index.js';
import {
  createInfrastructureServices,
  type InfrastructureServices,
  type InfrastructureConfig,
} from './infrastructure/factory.js';
import { createMessageService, type MessageService } from './services/messages/message-service.js';
import { createThreadService, type ThreadService } from './services/threads/thread-service.js';
import { createFileService, type FileService } from './services/files/file-service.js';
import { createReactionService, type ReactionService } from './services/reactions/reaction-service.js';
import { createWorkspaceService, type WorkspaceService } from './services/workspace/workspace-service.js';

/**
 * Configuration for the modular Slack service
 */
export interface ModularSlackConfig {
  // Feature flags for gradual rollout
  useModularArchitecture: boolean;
  enableModularMessages: boolean;
  enableModularThreads: boolean;
  enableModularFiles: boolean;
  enableModularReactions: boolean;
  enableModularWorkspace: boolean;
  
  // Performance monitoring
  enablePerformanceMetrics: boolean;
  monitorLegacyComparison: boolean;
}

/**
 * Domain service registry containing all service implementations
 */
export interface DomainServiceRegistry {
  messages: MessageService;
  threads: ThreadService;
  files: FileService;
  reactions: ReactionService;
  workspace: WorkspaceService;
}

/**
 * Method registry mapping method names to service implementations
 */
export interface ServiceMethodRegistry {
  // Message operations
  sendMessage: (args: unknown) => Promise<any>;
  listChannels: (args: unknown) => Promise<any>;
  getChannelHistory: (args: unknown) => Promise<any>;
  getUserInfo: (args: unknown) => Promise<any>;
  searchMessages: (args: unknown) => Promise<any>;
  getChannelInfo: (args: unknown) => Promise<any>;

  // Thread operations
  findThreadsInChannel: (args: unknown) => Promise<any>;
  getThreadReplies: (args: unknown) => Promise<any>;
  searchThreads: (args: unknown) => Promise<any>;
  analyzeThread: (args: unknown) => Promise<any>;
  summarizeThread: (args: unknown) => Promise<any>;
  extractActionItems: (args: unknown) => Promise<any>;
  postThreadReply: (args: unknown) => Promise<any>;
  createThread: (args: unknown) => Promise<any>;
  markThreadImportant: (args: unknown) => Promise<any>;
  identifyImportantThreads: (args: unknown) => Promise<any>;
  exportThread: (args: unknown) => Promise<any>;
  findRelatedThreads: (args: unknown) => Promise<any>;
  getThreadMetrics: (args: unknown) => Promise<any>;
  getThreadsByParticipants: (args: unknown) => Promise<any>;

  // File operations
  uploadFile: (args: unknown) => Promise<any>;
  listFiles: (args: unknown) => Promise<any>;
  getFileInfo: (args: unknown) => Promise<any>;
  deleteFile: (args: unknown) => Promise<any>;
  shareFile: (args: unknown) => Promise<any>;
  analyzeFiles: (args: unknown) => Promise<any>;
  searchFiles: (args: unknown) => Promise<any>;

  // Reaction operations
  addReaction: (args: unknown) => Promise<any>;
  removeReaction: (args: unknown) => Promise<any>;
  getReactions: (args: unknown) => Promise<any>;
  getReactionStatistics: (args: unknown) => Promise<any>;
  findMessagesByReactions: (args: unknown) => Promise<any>;

  // Workspace operations
  getWorkspaceInfo: (args: unknown) => Promise<any>;
  listTeamMembers: (args: unknown) => Promise<any>;
  getWorkspaceActivity: (args: unknown) => Promise<any>;
  getServerHealth: (args: unknown) => Promise<any>;
}

/**
 * Complete service registry with infrastructure and domain services
 */
export interface SlackServiceRegistry {
  infrastructure: InfrastructureServices;
  services: DomainServiceRegistry;
  methods: ServiceMethodRegistry;
  config: ModularSlackConfig;
}

/**
 * Parse modular configuration from CONFIG
 */
export function parseModularConfig(): ModularSlackConfig {
  return {
    // Feature flags for gradual rollout
    useModularArchitecture: CONFIG.USE_MODULAR_ARCHITECTURE,
    enableModularMessages: CONFIG.ENABLE_MODULAR_MESSAGES,
    enableModularThreads: CONFIG.ENABLE_MODULAR_THREADS,
    enableModularFiles: CONFIG.ENABLE_MODULAR_FILES,
    enableModularReactions: CONFIG.ENABLE_MODULAR_REACTIONS,
    enableModularWorkspace: CONFIG.ENABLE_MODULAR_WORKSPACE,
    
    // Performance monitoring
    enablePerformanceMetrics: CONFIG.ENABLE_PERFORMANCE_METRICS,
    monitorLegacyComparison: CONFIG.MONITOR_LEGACY_COMPARISON,
  };
}

/**
 * Create infrastructure services from current CONFIG
 */
export function createInfrastructureFromConfig(): InfrastructureServices {
  const infraConfig: InfrastructureConfig = {
    botToken: CONFIG.SLACK_BOT_TOKEN,
    userToken: CONFIG.SLACK_USER_TOKEN,
    useUserTokenForRead: CONFIG.USE_USER_TOKEN_FOR_READ,
    enableRateLimit: CONFIG.SLACK_ENABLE_RATE_LIMIT_RETRY,
    rateLimitRetries: CONFIG.SLACK_RATE_LIMIT_RETRIES,
    maxRequestConcurrency: CONFIG.SLACK_MAX_REQUEST_CONCURRENCY,
    rejectRateLimitedCalls: CONFIG.SLACK_REJECT_RATE_LIMITED_CALLS,
    logLevel: CONFIG.LOG_LEVEL,
  };

  return createInfrastructureServices(infraConfig);
}

/**
 * Create domain services with infrastructure dependencies
 */
export function createDomainServices(infrastructure: InfrastructureServices): DomainServiceRegistry {
  return {
    messages: createMessageService(infrastructure),
    threads: createThreadService(infrastructure),
    files: createFileService(infrastructure),
    reactions: createReactionService(infrastructure),
    workspace: createWorkspaceService(infrastructure),
  };
}

/**
 * Create method registry that maps method names to service implementations
 */
export function createServiceMethodRegistry(services: DomainServiceRegistry): ServiceMethodRegistry {
  return {
    // Message operations
    sendMessage: services.messages.sendMessage,
    listChannels: services.messages.listChannels,
    getChannelHistory: services.messages.getChannelHistory,
    getUserInfo: services.messages.getUserInfo,
    searchMessages: services.messages.searchMessages,
    getChannelInfo: services.messages.getChannelInfo,

    // Thread operations
    findThreadsInChannel: services.threads.findThreadsInChannel,
    getThreadReplies: services.threads.getThreadReplies,
    searchThreads: services.threads.searchThreads,
    analyzeThread: services.threads.analyzeThread,
    summarizeThread: services.threads.summarizeThread,
    extractActionItems: services.threads.extractActionItems,
    postThreadReply: services.threads.postThreadReply,
    createThread: services.threads.createThread,
    markThreadImportant: services.threads.markThreadImportant,
    identifyImportantThreads: services.threads.identifyImportantThreads,
    exportThread: services.threads.exportThread,
    findRelatedThreads: services.threads.findRelatedThreads,
    getThreadMetrics: services.threads.getThreadMetrics,
    getThreadsByParticipants: services.threads.getThreadsByParticipants,

    // File operations
    uploadFile: services.files.uploadFile,
    listFiles: services.files.listFiles,
    getFileInfo: services.files.getFileInfo,
    deleteFile: services.files.deleteFile,
    shareFile: services.files.shareFile,
    analyzeFiles: services.files.analyzeFiles,
    searchFiles: services.files.searchFiles,

    // Reaction operations
    addReaction: services.reactions.addReaction,
    removeReaction: services.reactions.removeReaction,
    getReactions: services.reactions.getReactions,
    getReactionStatistics: services.reactions.getReactionStatistics,
    findMessagesByReactions: services.reactions.findMessagesByReactions,

    // Workspace operations
    getWorkspaceInfo: services.workspace.getWorkspaceInfo,
    listTeamMembers: services.workspace.listTeamMembers,
    getWorkspaceActivity: services.workspace.getWorkspaceActivity,
    getServerHealth: services.workspace.getServerHealth,
  };
}

/**
 * Create complete Slack service registry with infrastructure and domain services
 */
export function createSlackServiceRegistry(config?: ModularSlackConfig): SlackServiceRegistry {
  const finalConfig = config || parseModularConfig();
  
  // Create infrastructure services
  const infrastructure = createInfrastructureFromConfig();
  
  // Create domain services with dependencies
  const services = createDomainServices(infrastructure);
  
  // Create method registry
  const methods = createServiceMethodRegistry(services);

  return {
    infrastructure,
    services,
    methods,
    config: finalConfig,
  };
}

/**
 * Performance metrics for monitoring legacy vs modular implementation
 */
export interface PerformanceMetrics {
  methodName: string;
  implementationType: 'legacy' | 'modular';
  executionTime: number;
  success: boolean;
  timestamp: Date;
  errorType?: string;
}

/**
 * Performance monitoring utility
 */
export class PerformanceMonitor {
  private metrics: PerformanceMetrics[] = [];
  private maxMetrics = 1000; // Keep last 1000 metrics

  /**
   * Record performance metrics for a method execution
   */
  record(metric: PerformanceMetrics): void {
    this.metrics.push(metric);
    
    // Keep only the most recent metrics
    if (this.metrics.length > this.maxMetrics) {
      this.metrics = this.metrics.slice(-this.maxMetrics);
    }
  }

  /**
   * Get performance statistics for comparison
   */
  getStats(methodName?: string): {
    legacy: { avgTime: number; successRate: number; count: number };
    modular: { avgTime: number; successRate: number; count: number };
  } {
    const filteredMetrics = methodName
      ? this.metrics.filter(m => m.methodName === methodName)
      : this.metrics;

    const legacyMetrics = filteredMetrics.filter(m => m.implementationType === 'legacy');
    const modularMetrics = filteredMetrics.filter(m => m.implementationType === 'modular');

    const calculateStats = (metrics: PerformanceMetrics[]) => ({
      avgTime: metrics.length > 0 
        ? metrics.reduce((sum, m) => sum + m.executionTime, 0) / metrics.length 
        : 0,
      successRate: metrics.length > 0 
        ? metrics.filter(m => m.success).length / metrics.length 
        : 0,
      count: metrics.length,
    });

    return {
      legacy: calculateStats(legacyMetrics),
      modular: calculateStats(modularMetrics),
    };
  }

  /**
   * Clear all metrics
   */
  clear(): void {
    this.metrics = [];
  }

  /**
   * Export metrics for analysis
   */
  export(): PerformanceMetrics[] {
    return [...this.metrics];
  }
}